package de.novatec.marioai.tools;

import java.awt.Color;
import java.awt.Graphics;
import java.util.ArrayList;
import java.util.List;

import ch.idsia.ai.agents.Agent;
import ch.idsia.mario.engine.LevelScene;
import ch.idsia.mario.environments.Environment;
import de.novatec.mario.engine.generalization.Coordinates;
import de.novatec.mario.engine.generalization.Entities;
import de.novatec.mario.engine.generalization.Tiles;
import de.novatec.mario.engine.generalization.Entities.EntityType;
import de.novatec.mario.engine.generalization.Entity;
import de.novatec.mario.engine.generalization.Tile;
import de.novatec.mario.engine.generalization.Tiles.TileType;

/**
 * Helper class to implement a proper Agent.
 * Implement {@link #doAiLogic()},{@link #getName()} and if needed {@link #reset()}.
 * @author rgu
 *
 */
public abstract class MarioNtAgent implements Agent{
	
	private MarioInput input=new MarioInput();
	
	private MarioControl control=new MarioControl(input);
	
	private Environment env;
	
	private Tiles tiles;
	
	private Entities entities;
	
	private static final int ENEMY_CHECK_DISTANCE=4/*,BRICK_CHECK_DISTANCE=3*/;
	
	private ArrayList<Coordinates> coordList=new ArrayList<>();

	/**
	 * Resets the agent. Should be overridden if needed.
	 */
	@Override
	public void reset() {		
	}

	/**
	 * Do not touch this.
	 */
	@Override
	public final boolean[] getAction(Environment observation) {
		
		env=observation;
		if(tiles==null) tiles=new Tiles(observation);
		else tiles.setEnvironment(observation);
		
		if(entities==null) entities=new Entities(observation);
		else entities.setEnvironment(observation);
		
		control.setEnvironment(observation);
		
		control.tick();
		input.tick();
		
		MarioInput input=doAiLogic();
		
		return input.toArray();
	}

	/**
	 * Returns the AGENT_TYPE of the agent, not very useful anymore.
	 */
	@Override
	public final AGENT_TYPE getType() {
		return AGENT_TYPE.AI;
	}

	/**
	 * Should be overridden. Naming the agent.
	 */
	@Override
	public String getName() {
		return "This should not be seen! Please give your agent a proper name!";
	}

	@Override
	public final void setName(String name) {
			}
	
	/**
	 * Implement the logic of your agent here!
	 * @return MarioInput generated by Agent's logic
	 */
	public abstract MarioInput doAiLogic(); // must be implemented by agents who extend this!
		
	/**
	 * 
	 * @return the actual instance of MarioInput
	 */
	public final MarioInput getMarioInput() {
		return input;
	}
	
	/**
	 * 
	 * @return the actual instance of MarioControl
	 */
	public final MarioControl getMarioControl() {
		return control;
	}
	
	////////////////////////////////
	// Mario interaction methods
	////////////////////////////////
	
	/**
	 * Mario will move right.
	 */
	public final void moveRight() {
		this.getMarioControl().moveRight();
	}
	
	/**
	 * Mario will move left
	 */
	public final void moveLeft() {
		this.getMarioControl().moveLeft();
	}
	
	/**
	 * Mario will sprint
	 */
	public final void sprint() {
		this.getMarioControl().sprint();
	}
	
	/**
	 * Mario will jump
	 */
	public final void jump() {
		this.getMarioControl().jump();
	}
	
	/**
	 * Mario will shoot
	 */
	public final void shoot() {
		this.getMarioControl().shoot();
	}
	
	////////////////////////////////
	// Environment detection methods
	////////////////////////////////
	
	/**
	 * Can Mario shoot?
	 * @return
	 */
	public final boolean mayShoot() {
		return this.env.mayShoot();
	}
	
	/**
	 * Can Mario jump?
	 * @return
	 */
	public final boolean mayJump() {
		return this.env.mayMarioJump();
	}
	
	/**
	 * Marios Position as an array. [0] marioX [1] marioY
	 * @return
	 */
	public final float[] getMarioFloatPos(){
		return this.env.getMarioFloatPos();
	}
	
	/**
	 * 
	 * @return Mario's X Position 
	 */
	public final float getMarioX() {
		return env.getLevelScene().getMarioX();
	}
	
	/**
	 * 
	 * @return Mario's Y Position
	 */
	public final float getMarioY() {
		return env.getLevelScene().getMarioY();
	}
	
	/**
	 * Is Mario on the ground?
	 * @return
	 */
	public final boolean isOnGround() {
		return this.env.isMarioOnGround();
	}
	
	/**
	 * Is Mario falling?
	 * @return
	 */
	public final boolean isFalling() {
		return this.env.isFalling();
	}
	
	/**
	 * Is Mario carrying a shell?
	 * @return
	 */
	public final boolean isCarrying() {
		return this.env.isMarioCarrying();
	}
	
	///--- Simple Detection Methods
	
	/**
	 * Is a brick ahead? Defined as: isBrick(1,0)||isBrick(1,-1)||isBrick(2, 0)||isBrick(2, -1)||isBrick(3, 0)||isBrick(3, -1) (all Coordinates relative to Mario)
	 * @return
	 */
	public final boolean isBrickAhead() {
		return isBrick(1,0)||isBrick(1,-1)||isBrick(2, 0)||isBrick(2, -1)||isBrick(3, 0)||isBrick(3, -1);
	}
	
	/**
	 * Is a slope ahead? Defined as: isBrick(0,1)&&isEmpty(1, 1)&&isEmpty(2, 1) (all Coordinates relative to Mario)
	 * @return
	 */
	public final boolean isSlopeAhead() {
		return isBrick(0,1)&&isEmpty(1, 1)&&isEmpty(2, 1);
	}
	
	/**
	 * Is a deep slope ahead? Defined as: isSlopeAhead()&&isEmpty(1,2)&&isEmpty(2, 2); (all Coordinates relative to Mario)
	 * @return
	 */
	public final boolean isDeepSlopeAhead() {
		return isSlopeAhead()&&isEmpty(1,2)&&isEmpty(2, 2);
	}
	
	/**
	 * Is an enemy ahead? 
	 * @return
	 */
	public final boolean isEnemyAhead() {

		for(int i=1;i<ENEMY_CHECK_DISTANCE;i++) {
			if(isDangerousAt(i, 0)||isDangerousAt(i, -1)) return true;
		}
		return false;
	}
	
	/**
	 * Is a hole ahead? Defined as: isEmpty(1,env.getLevelScene().getLevelHight()-1-(int)getMarioY()/16)&&isEmpty(2,env.getLevelScene().getLevelHight()-1-(int)getMarioY()/16)
	 * @return
	 */
	public final boolean isHoleAhead() { 
		return isEmpty(1,env.getLevelScene().getLevelHight()-1-(int)getMarioY()/16)&&isEmpty(2,env.getLevelScene().getLevelHight()-1-(int)getMarioY()/16);
	}
	
	/**
	 * Is Mario beyond a Questionbrick? 
	 * @return
	 */
	public final boolean isQuestionbrickAbove() {
		return isQuestionbrick(0,-1)||isQuestionbrick(0,-2)||isQuestionbrick(0,-3);
	}
	
	////--- Tiles - Abstracted Level Information
	
	/**
	 * Returns the tiles member
	 * @return
	 */
	public final Tiles getTiles() {
		return tiles;
	}

	/**
	 * Returns all tiles on screen that are defined as interactive. (Questionbrick,Breakable Brick, Coins)
	 * @return
	 */
	public final List<Tile> getInteractiveBlocksOnScreen(){
		return tiles.getInteractiveBlocksOnScreen();
	}
	
	/**
	 * Gets the type of the Tile at (x,y) (relative to Mario)
	 * @param x
	 * @param y
	 * @return
	 */
	public final TileType getTile(int x, int y) {
		return tiles.getTile(x, y);
	}
	
	/**
	 * Is there a Brick at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final  boolean isBrick(int x,int y) {
		return tiles.isBrick(x, y);
	}
	
	/**
	 * Is there no Tile at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isEmpty(int x, int y) {
		return tiles.isEmpty(x, y);
	}
	
	/**
	 * Is there some Tile at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isNotEmpty(int x,int y) {
		return tiles.isNotEmpty(x, y);
	}
	
	public final boolean isQuestionbrick(int x,int y) {
		return tiles.isQuestionbrick(x, y);
	}
	////--- Entities - Abstracted Enemy Detection
	
	/**
	 * Returns the entitie member.
	 * @return
	 */
	public final Entities getEntities() {
		return entities;
	}
	
	/**
	 * Returns all entities at (x,y).
	 * @param x
	 * @param y
	 * @return
	 */
	public final List<Entity> getEntities(int x,int y){
		return entities.getEntities(x, y);
	}
	
	/**
	 * Returns all entities on screen.
	 * @return
	 */
	public final List<Entity> getAllEntitiesOnScreen(){
		return entities.getEntities();
	}
	
	/**
	 * Returns all entites defined as enemies on screen. (Goomba, Kooper, EnemyFlower etc.)
	 * @return
	 */
	public final List<Entity> getAllEnemiesOnScreen(){
		return entities.getEnemies();
	}
	
	/**
	 * Returns all entities defined as enemies at (x,y).
	 * @param x
	 * @param y
	 * @return
	 */
	public final List<Entity> getEnemies(int x,int y){
		return entities.getEnemies(x,y);
	}
		
	/**
	 * Returns the EntityType of the most dangerous Entity at (x,y).
	 * @param x
	 * @param y
	 * @return
	 */
	public final EntityType getMostDangrousEntityTypeAt(int x,int y) {
		return entities.getMostDangrousEntityTypeAt(x, y);
	}
	
	/**
	 * Is there no Entity at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isNothingAt (int x,int y) {
		return entities.isNothingAt(x, y);
	}
	
	/**
	 * Is there an Entity at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isSomethingAt (int x, int y) {
		return entities.isSomethingAt(x, y);
	}
	
	/**
	 * Is a dangerous Entity at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isDangerousAt(int x, int y) {
		return entities.isDangerousAt(x, y);
	}
	
	/**
	 * Is a squishable Entity at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isSquishableAt(int x, int y) {
		return entities.isSquishableAt(x, y);
	}
	
	/**
	 * Is a shootable Entity at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isShootableAt(int x, int y) {
		return entities.isShootableAt(x, y);
	}
	
	/**
	 * Is a collectible Entity at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isCollectableAt(int x,int y) {
		return entities.isCollectableAt(x, y);
	}
	
	//--- A* Helper Methods
	
	/**
	 * Returns a deep copy of the actual LevelScene of the {@link #env}.
	 * @return
	 */
	public final LevelScene getDeepCopyOfLevelScene(){
		return env.getLevelScene().getDeepCopy();
	}
	
	////////////////////////////////
	// Debug methods
	////////////////////////////////

	
	/**
	 * Shows an Ascii representation of Mario's view
	 */
	public final void showMarioViewAsAscii() {
		env.showMarioViewAsAscii();
	}
	
	/**
	 * Given Coordinate will be added to the List of Coordinates to be drawn if Debug View is enabled.
	 * @param coord
	 */
	protected final void addCoordToDraw(Coordinates coord) {
		if(env.isDebugView()) this.coordList.add(coord);
		else this.coordList.clear();
	}
	
	/**
	 * Standard debug draw.
	 * @param og
	 * @param env
	 */
	public void debugDraw(Graphics og,Environment env) {
		Coordinates oldCoords=null; //new Coordinates((env.getLevelScene().getMarioX()),env.getLevelScene().getMarioY()-8);
		Color oldColor=og.getColor();
		og.setColor(Color.RED);
		for(Coordinates next:coordList) {
			if(oldCoords!=null)og.drawLine((int) (oldCoords.getX()-env.getLevelScene().getMarioXCam()), (int) oldCoords.getY(), (int) (next.getX()-env.getLevelScene().getMarioXCam()), (int) next.getY());
			oldCoords=next;
		}
		og.setColor(oldColor);
		coordList.clear();
	}
	
}
