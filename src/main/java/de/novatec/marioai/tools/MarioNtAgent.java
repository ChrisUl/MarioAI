package de.novatec.marioai.tools;

import java.awt.Color;
import java.awt.Graphics;
import java.util.ArrayList;
import java.util.List;

import ch.idsia.ai.agents.Agent;
import ch.idsia.mario.engine.LevelScene;
import ch.idsia.mario.environments.Environment;
import de.novatec.mario.engine.generalization.Coordinates;
import de.novatec.mario.engine.generalization.Entities;
import de.novatec.mario.engine.generalization.Tiles;
import de.novatec.mario.engine.generalization.Entities.EntityType;
import de.novatec.mario.engine.generalization.Entity;
import de.novatec.mario.engine.generalization.Tile;
import de.novatec.mario.engine.generalization.Tiles.TileType;

/**
 * Helper class to implement a proper Agent.
 * Implement {@link #doAiLogic()},{@link #getName()} and if needed {@link #reset()}.
 * @author rgu
 *
 */
public abstract class MarioNtAgent implements Agent{
	
	private MarioInput input=new MarioInput();
	
	private MarioControl control=new MarioControl(input);
	
	private Environment env;
	
	private Tiles tiles;
	
	private Entities entities;
	
	private static final int ENEMY_CHECK_DISTANCE=4/*,BRICK_CHECK_DISTANCE=3*/;
	
	private List<Coordinates> coordList=new ArrayList<>(), oldCoordList=new ArrayList<>(); 

	/**
	 * Resets the agent. Should be overridden if needed.
	 */
	@Override
	public void reset() {		
	}

	/**
	 * Do not touch this.
	 */
	@Override
	public final boolean[] getAction(Environment observation) {
		
		env=observation;
		if(tiles==null) tiles=new Tiles(observation);
		else tiles.setEnvironment(observation);
		
		if(entities==null) entities=new Entities(observation);
		else entities.setEnvironment(observation);
		
		control.setEnvironment(observation);
		
		control.tick();
		input.tick();
		
		MarioInput input=doAiLogic();
		if(input==null) {
			System.err.println("MarioInput is null! Did you return getMarioInput() in your doAiLogic Method?");
			System.err.println("Simulation will be stopped!");
			System.exit(1);
		}
		
		return input.toArray();
	}

	/**
	 * Returns the AGENT_TYPE of the agent, not very useful anymore.
	 */
	@Override
	public AGENT_TYPE getType() {
		return AGENT_TYPE.AI;
	}

	/**
	 * Should be overridden. Naming the agent.
	 */

	public abstract String getName();

	@Override
	public final void setName(String name) {
			}
	
	/**
	 * Implement the logic of your agent here!
	 * @return MarioInput generated by Agent's logic
	 */
	public abstract MarioInput doAiLogic(); // must be implemented by agents who extend this!
		
	/**
	 * 
	 * @return the actual instance of MarioInput
	 */
	public final MarioInput getMarioInput() {
		return input;
	}
	
	/**
	 * 
	 * @return the actual instance of MarioControl
	 */
	public final MarioControl getMarioControl() {
		return control;
	}
	
	////////////////////////////////
	// Mario interaction methods
	////////////////////////////////
	
	/**
	 * Mario will move right.
	 */
	public final void moveRight() {
		this.getMarioControl().moveRight();
	}
	
	/**
	 * Mario will move left
	 */
	public final void moveLeft() {
		this.getMarioControl().moveLeft();
	}
	
	/**
	 * Mario will sprint
	 */
	public final void sprint() {
		this.getMarioControl().sprint();
	}
	
	/**
	 * Mario will jump
	 */
	public final void jump() {
		this.getMarioControl().jump();
	}
	
	/**
	 * Mario will shoot
	 */
	public final void shoot() {
		this.getMarioControl().shoot();
	}
	
	////////////////////////////////
	// Environment detection methods
	////////////////////////////////
	
	/**
	 * Can Mario shoot?
	 * @return
	 */
	public final boolean mayShoot() {
		return this.env.mayMarioShoot();
	}
	
	/**
	 * Can Mario jump?
	 * @return
	 */
	public final boolean mayJump() {
		return this.env.mayMarioJump();
	}
	
	/**
	 * Mario's Map Position as Coordinates
	 * @return
	 */
	public final Coordinates getMarioPos(){
		return this.env.getMarioPos();
	}
	
	/**
	 * Mario's Physical Position as Coordinates
	 * @return
	 */
	public final Coordinates getMarioFloatPos() {
		return this.env.getMarioFloatPos();
	}
	
	/**
	 * Mario's Map X Position
	 * @return
	 */
	public final int getMarioMapX() {
		return env.getMarioMapX();
	}
	
	/**
	 * Mario's Map Y Position
	 * @return
	 */
	public final int getMarioMapY() {
		return env.getMarioMapY();
	}
	
	/**
	 * 
	 * @return Mario's Physical X Position 
	 */
	public final float getMarioX() {
		return env.getLevelScene().getMarioX();
	}
	
	/**
	 * 
	 * @return Mario's Physical Y Position
	 */
	public final float getMarioY() {
		return env.getLevelScene().getMarioY();
	}
	
	/**
	 * Is Mario on the ground?
	 * @return
	 */
	public final boolean isOnGround() {
		return this.env.isMarioOnGround();
	}
	
	/**
	 * Is Mario falling?
	 * @return
	 */
	public final boolean isFalling() {
		return this.env.isMarioFalling();
	}
	
	/**
	 * Is Mario carrying a shell?
	 * @return
	 */
	public final boolean isCarrying() {
		return this.env.isMarioCarrying();
	}
	
	///--- Simple Detection Methods
	
	/**
	 * Is a brick ahead? Defined as: isBrick(1,0)||isBrick(1,-1)||isBrick(2, 0)||isBrick(2, -1)||isBrick(3, 0)||isBrick(3, -1) (all Coordinates relative to Mario)
	 * @return
	 */
	public final boolean isBrickAhead() {
		return isBrick(1,0)||isBrick(1,-1)||isBrick(2, 0)||isBrick(2, -1)||isBrick(3, 0)||isBrick(3, -1);
	}
	
	/**
	 * Is a slope ahead? Defined as: isBrick(0,1)&&isEmpty(1, 1)&&isEmpty(2, 1) (all Coordinates relative to Mario)
	 * @return
	 */
	public final boolean isSlopeAhead() {
		return isBrick(0,1)&&isEmpty(1, 1)&&isEmpty(2, 1);
	}
	
	/**
	 * Is a deep slope ahead? Defined as: isSlopeAhead()&&isEmpty(1,2)&&isEmpty(2, 2); (all Coordinates relative to Mario)
	 * @return
	 */
	public final boolean isDeepSlopeAhead() {
		return isSlopeAhead()&&isEmpty(1,2)&&isEmpty(2, 2);
	}
	
	/**
	 * Is an enemy ahead? 
	 * @return
	 */
	public final boolean isEnemyAhead() {

		for(int i=1;i<ENEMY_CHECK_DISTANCE;i++) {
			if(isDangerousAt(i, 0)||isDangerousAt(i, -1)) return true;
		}
		return false;
	}
	
	/**
	 * Is a hole ahead? Defined as: isEmpty(1,env.getLevelScene().getLevelHight()-1-(int)getMarioY()/16)&&isEmpty(2,env.getLevelScene().getLevelHight()-1-(int)getMarioY()/16)
	 * @return
	 */
	public final boolean isHoleAhead() { 
		return isEmpty(1,env.getLevelScene().getLevelHight()-1-(int)getMarioY()/16)&&isEmpty(2,env.getLevelScene().getLevelHight()-1-(int)getMarioY()/16);
	}
	
	/**
	 * Is Mario beyond a Questionbrick? 
	 * @return
	 */
	public final boolean isQuestionbrickAbove() {
		return isQuestionbrick(0,-1)||isQuestionbrick(0,-2)||isQuestionbrick(0,-3);
	}
	
	////--- Tiles - Abstracted Level Information
	
	/**
	 * Returns the tiles member
	 * @return
	 */
	public final Tiles getTiles() {
		return tiles;
	}

	/**
	 * Returns all tiles on screen that are defined as interactive. (Questionbrick,Breakable Brick, Coins)
	 * @return
	 */
	public final List<Tile> getInteractiveBlocksOnScreen(){
		return tiles.getInteractiveBlocksOnScreen();
	}
	
	/**
	 * Gets the type of the Tile at (x,y) (relative to Mario)
	 * @param x
	 * @param y
	 * @return
	 */
	public final TileType getTile(int x, int y) {
		return tiles.getTile(x, y);
	}
	
	/**
	 * Is there a Brick at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final  boolean isBrick(int x,int y) {
		return tiles.isBrick(x, y);
	}
	
	/**
	 * Is there no Tile at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isEmpty(int x, int y) {
		return tiles.isEmpty(x, y);
	}
	
	/**
	 * Is there some Tile at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isNotEmpty(int x,int y) {
		return tiles.isNotEmpty(x, y);
	}
	
	public final boolean isQuestionbrick(int x,int y) {
		return tiles.isQuestionbrick(x, y);
	}
	////--- Entities - Abstracted Enemy Detection
	
	/**
	 * Returns the entities member.
	 * @return
	 */
	public final Entities getEntities() {
		return entities;
	}
	
	/**
	 * Returns all entities at (x,y).
	 * @param x
	 * @param y
	 * @return
	 */
	public final List<Entity> getEntitiesAt(int x,int y){
		return entities.getEntitiesAt(x, y);
	}
	
	/**
	 * Returns all entities on screen.
	 * @return
	 */
	public final List<Entity> getAllEntitiesOnScreen(){
		return entities.getEntitiesOnScreen();
	}
	
	/**
	 * Returns all entites defined as enemies on screen. (Goomba, Kooper, EnemyFlower etc.)
	 * @return
	 */
	public final List<Entity> getAllEnemiesOnScreen(){
		return entities.getEnemiesOnScreen();
	}
	
	/**
	 * Returns all entities defined as enemies at (x,y).
	 * @param x
	 * @param y
	 * @return
	 */
	public final List<Entity> getEnemiesAt(int x,int y){
		return entities.getEnemiesAt(x,y);
	}
	
	public final List<Entity> getCollectiblesOnScreen(){
		return entities.getCollectiblesOnScreen();
	}
		
	/**
	 * Returns the EntityType of the most dangerous Entity at (x,y).
	 * @param x
	 * @param y
	 * @return
	 */
	public final EntityType getMostDangrousEntityTypeAt(int x,int y) {
		return entities.getMostDangrousEntityTypeAt(x, y);
	}
	
	/**
	 * Is there no Entity at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isNothingAt (int x,int y) {
		return entities.isNothingAt(x, y);
	}
	
	/**
	 * Is there an Entity at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isSomethingAt (int x, int y) {
		return entities.isSomethingAt(x, y);
	}
	
	/**
	 * Is a dangerous Entity at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isDangerousAt(int x, int y) {
		return entities.isDangerousAt(x, y);
	}
	
	/**
	 * Is a squishable Entity at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isSquishableAt(int x, int y) {
		return entities.isSquishableAt(x, y);
	}
	
	/**
	 * Is a shootable Entity at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isShootableAt(int x, int y) {
		return entities.isShootableAt(x, y);
	}
	
	/**
	 * Is a collectible Entity at (x,y)?
	 * @param x
	 * @param y
	 * @return
	 */
	public final boolean isCollectableAt(int x,int y) {
		return entities.isCollectableAt(x, y);
	}
	
	/**
	 * The eucledian Distance between Mario and the given entity. 
	 * @param entity
	 * @return
	 */
	public final double getDistance(Entity entity) {
		return Coordinates.getDistanceFromTo(0, 0, entity.getRelX(), entity.getRelY());
	}
	
	//--- A* Helper Methods
	
	/**
	 * Returns a deep copy of the actual LevelScene of the {@link #env}.
	 * @return
	 */
	public final LevelScene getDeepCopyOfLevelScene(){
		return env.getLevelScene().getDeepCopy();
	}
	
	/**
	 * 
	 * @return Score of the actual LevelScene 
	 */
	public final double getActualScore() {
		return env.getLevelScene().getScore();
	}
	
	////////////////////////////////
	// Debug methods
	////////////////////////////////

	
	/**
	 * Shows an Ascii representation of Mario's view
	 */
	public final void showMarioViewAsAscii() {
		env.showMarioViewAsAscii();
	}
	
	/**
	 * Given Coordinate will be added to the List of Coordinates to be drawn if Debug View is enabled.
	 * @param coord
	 */
	protected final void addCoordToDraw(Coordinates coord) {
		 this.coordList.add(coord);
	}
	
	/**
	 * Standard debug draw.
	 * @param og
	 * @param env
	 */
	public void debugDraw(Graphics og,Environment env,boolean debug,boolean delete) {
		
		if(!delete) coordList=getDeepCopy(oldCoordList);
		if(debug) {
		Coordinates oldCoords=null; 
		Color oldColor=og.getColor();
		og.setColor(Color.RED);
		for(Coordinates next:coordList) {
			if(oldCoords!=null)og.drawLine((int) (oldCoords.getX()-env.getLevelScene().getMarioXCam()), (int) oldCoords.getY(), (int) (next.getX()-env.getLevelScene().getMarioXCam()), (int) next.getY());
			oldCoords=next;
		}
		og.setColor(oldColor);
		}
		oldCoordList.clear();
		oldCoordList=getDeepCopy(coordList);
		coordList.clear();
	}
	
	/**
	 * Helper Method to make a deep copy of a coordinates list
	 * @param toCopy the list to copy
	 * @return a deep copy of the given list
	 */
	private List<Coordinates> getDeepCopy(List<Coordinates> toCopy){
		List<Coordinates> res=new ArrayList<>();
		
		for(Coordinates next:toCopy) {
			res.add(new Coordinates(next.getX(),next.getY()));
		}
		
		return res;
	}
	
}
